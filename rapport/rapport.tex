
%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt]{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{array,multirow,makecell}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst} %Indentation début de paragraphe
\usepackage{float}
\usepackage{colortbl} %Clouleur tableau protoypes de fonctions
\usepackage{alltt}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{cases}
\usepackage{minted}
\usemintedstyle{friendly}
\definecolor{bg}{RGB}{255, 255, 255}


% Marges
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

%  Mise en place des pieds de page et en-tÃªtes.
\pagestyle{fancy}
\lhead{r007K17} % Top left header
\chead{rkduck the LKM Rootkit} % Top center head
\rhead{Master CSI} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ sur\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

%\setlength\parindent{10pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%   Page de Titre
%----------------------------------------------------------------------------------------

\title{
\pagenumbering{roman} \setcounter{page}{0} %La page courante sera numérotée en roman et aura l'indice 0 => Pas de numéro car pas de 0 en roman
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{\hmwkDueDate}\\
\vspace{0.1in}\large{\textit{\hmwkClassInstructor\ }}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}

%----------------------------------------------------------------------------------------
%   Page de garde
%----------------------------------------------------------------------------------------


\makeatletter
\def\clap#1{\hbox to 0pt{\hss #1\hss}}%
\def\ligne#1{%
\hbox to \hsize{%
\vbox{\centering #1}}}%
\def\haut#1#2#3{%
\hbox to \hsize{%
\rlap{\vtop{\raggedright #1}}%
\hss
\clap{\vtop{\centering #2}}%
\hss
\llap{\vtop{\raggedleft #3}}}}%
\def\bas#1#2#3{%
\hbox to \hsize{%
\rlap{\vbox{\raggedright #1}}%
\hss
\clap{\vbox{\centering #2}}%
\hss
\llap{\vbox{\raggedleft #3}}}}%
\def\maketitle{%
\thispagestyle{empty}\vbox to \vsize{%
\haut{}{\@blurb}{}
\vfill
\vspace{1cm}
\begin{flushleft}
\huge \@title
\end{flushleft}
\par
\hrule height 1pt
\par
\begin{flushright}
\Large \@author
\par
\end{flushright}
\vfill

\vfill
\bas{}{\@location, le 21 Mars 2016}{}
}%
\cleardoublepage
}
\def\date#1{\def\@date{#1}}
\def\author#1{\def\@author{#1}}
\def\title#1{\def\@title{#1}}
\def\location#1{\def\@location{#1}}
\def\blurb#1{\def\@blurb{#1}}
\date{\today}
\location{Bordeaux}\blurb{}
\makeatother
\title{\textbf{\textit{rkduck} : kernel rootkit pour Linux 4.x.x}}
\author{Thomas Le Bourlot, Maxime Peterlin, Martial Puygrenier}
\location{Bordeaux}
\blurb{
Université de Bordeaux\\
Faculté de Sciences et Techniques
}%

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle
% {2cm}
\begin{abstract}
\thispagestyle{empty}
    Dans la continuité des travaux réalisés sur les rootkits sur les kernel 2.6.x et 3.x.x nous avons décidé de réaliser une étude des techniques d'injection de rootkits sur les kernels 4.x.x. Très peu de ressources récentes traitent du sujet et les sources des rootkits disponibles sur internet sont très souvent obsolètes suite aux modifications de certaines fonctions entre les différentes versions du noyau Linux. Vous retrouverez dans la bibliographie l'ensemble des ressources et articles qui nous ont aidés dans le développement et la conception du rootkit \texttt{rkduck}. Notre travail est disponible sur l'organisation github \href{https://github.com/QuokkaLight/}{QuokkaLight}.
\end{abstract}
% \vspace{2cm}

\vspace{5cm}
\begin{center}
\includegraphics[width=0.5\linewidth]{img/logo_blk.png} 
\end{center}
\newpage

%----------------------------------------------------------------------------------------
%   Table des matières
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC
\pagenumbering{arabic} \setcounter{page}{1} 
\thispagestyle{empty}
\renewcommand\contentsname{Sommaire}
\tableofcontents
\newpage

%----------------------------------------------------------------------------------------
%   Partie à remplir
%----------------------------------------------------------------------------------------

\newcommand*{\escape}[1]{\texttt{\textbackslash#1}}
\newcommand*{\escapeI}[1]{\texttt{\expandafter\string\csname #1\endcsname}}
\newcommand*{\escapeII}[1]{\texttt{\char`\\#1}}


\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

    Cet article traite des rootkits. Ce sont des programmes permettant de cacher la compromission d'une machine à ses utilisateurs légitimes. Plus précisément, nous expliquerons le développement de notre rootkit nommé \texttt{rkduck}, un LKM (Loadable Kernel Module) rootkit pour Linux v4.x.x. \\

    Nos propos seront développés de la manière suivante. Dans un premier temps, nous rappelerons en quoi consiste un rootkit et comment ils ont évolué au fil du temps. Une partie sera consacrée aux différentes méthodes d'injection de code dans le noyau Linux. Suite à cela, nous expliquerons comment notre rootkit détourne le fonctionnement du système pour cacher une activité malveillante et de quelle manière il reste persistant sur la machine. Nous expliquerons ensuite les fonctionnalités mise à disposition par notre rootkit pour finir sur les méthodes de détection existantes.

\section{Définition et évolution des rootkits}

    Afin de compromettre une machine, un attaquant passe généralement par la même série d'étapes. Une fois que des vulnérabilités dans le système ont été identifiées, l'attaquant les exploite afin de prendre la main sur le système jusqu'à compromettre entièrement ce dernier afin d'avoir les droits de super-utilisateur.
    Cependant, l'exploitation de failles dans un système ne peut être considéré comme un moyen sûr pour accéder à une machine, car le simple fait de corriger les vulnérabilités empêcherait d'y accéder à nouveau. C'est pourquoi il est nécessaire de faire persister l'accès après la compromission, ce qui est rendu possible par l'utilisation de rootkits.\\
    
    Les premiers types de rootkits utilisés étaient des ensembles de programmes qui permettaient de substituer les outils d'administration standard tels que ls, ps, etc. Ainsi, l'intrus avait le contrôle sur les sorties de se programme et pouvait cacher l'activité malicieuse qui se passait sur la machine. Cependant, il devenait fastidieux de cacher la compromission de la machine à l'administrateur légitime. Ce dernier pouvait utiliser plusieurs programmes effectuant la même action pour recouper les informations et ainsi découvrir des différences entre les résultats retournés révélant ainsi la présence d'un rootkit.\\
    
    Les attaquants se sont alors rendus compte qu'il était inutile de réécrire toute une suite de programmes, ce qui peut devenir très conséquent en terme de taille et en temps de développement. Il suffit de remonter aux fonctions utilisées par tous ces programmes d'administration : les appels systèmes. En supposant que l'intrus ait accès au kernel, il est possible d'intercepter les appels systèmes pour les rediriger vers des fonctions malveillantes afin de cacher la compromission de la machine. A partir du moment où l'attaquant a le contrôle sur le noyau du système, il devient difficile de détecter de manière fiable un rootkit, car les systèmes de sécurité opèrent au même niveau que ce dernier et des fonctions que l'on peut penser digne de confiance peuvent retourner des résultats falsifiés. \\
    C'est ce type de rootkit que nous allons étudier par la suite, notamment les rootkits s'injectant dans le système sous forme de modules kernel.

    % Petite partie sur les bootkits


\section{Injection en mémoire}

    Il existe plusieurs méthodes d'injection de code dans un noyau. Nous étudierons dans cette partie les deux méthodes les plus répandues à savoir l'utilisation du périphérique \texttt{/dev/mem}\cite{devmem} et des modules noyau. A titre informatif, il est également possible d'utiliser des vulnérabilités du noyau ou bien l'entrée \texttt{FireWire} qui permet d'avoir un accès direct à toute la mémoire de la machine, ce qui nécessite cependant un accès physique à cette dernière.\\

    Afin de développer \texttt{rkduck} nous nous sommes, dans un premier temps, tournés vers l'injection basée sur \texttt{/dev/mem}. Cependant, un patch de sécurité empêche son utilisation sur les versions 4.x.x du noyau Linux, ce qui fait que nous nous sommes finalement tournés vers la construction d'un LKM rootkit.

    \subsection{Injection via /dev/mem}
    
        \texttt{/dev/mem} est un fichier qui fournit un accès à une image de la mémoire physique de la machine. L'intérêt principal d'un tel fichier est de pouvoir accéder directement à la mémoire sans écrire un driver kernel, il devient alors plus aisé et rapide d'examiner la mémoire et de patcher le sytème. \texttt{/dev/mem} est un point d'entrée pour injecter du code malicieux, car, si un attaquant peut écrire dans \texttt{/dev/mem}, alors il pourra modifier des parties du kernel, notamment la table des appels systèmes ou encore les fonctions liées au \texttt{Virtual File System}, comme nous le verrons par la suite.\\
        
        L'intérêt de cette méthode est qu'elle est plus discrète que, par exemple, une injection via un module noyau. En effet, si on suppose qu'il est possible de charger un LKM et d'écrire dans \texttt{/dev/mem}, lorsqu'on injecte un LKM il est toujours possible d'effectuer une analyse comportementale ou bien de rajouter une vérification d'authenticité par signature cryptographique, alors que dans le cas de \texttt{/dev/mem}, l'injection est directe dans la mémoire kernel et il n'y a pas d'interface qui pourrait se charger de vérifier le caractère malveillant ou non du code injecté.\\
        
        Il existe également un fichier nommé \texttt{/dev/kmem}. C'est essentiellement le même fichier que \texttt{/dev/mem} sauf que dans le cas de \texttt{/dev/kmem} on accède à la mémoire virtuelle du kernel et non à la mémoire physique. La mémoire kernel possède peut fonctionner suivant deux modes. Le premier est un décalage par rapport à la mémoire physique, par exemple sur \texttt{x86} l'adresse physique \texttt{0x00000001} est mappée sur l'adresse virtuelle kernel \text{0xc0000001}. Le second mode repose sur la routine \texttt{vmalloc} qui est l'un des principaux mécanismes d'allocation de mémoire dynamique. Dans ce cas, le kernel ne sera pas contigüe en mémoire physique, même ce dernier verra les adresses virtuelles comme contigües.\\
        
        Nous avons cependant mis de côté ce type d'injection, car elle est aujourd'hui désactivée par défaut dans la plupart des distributions, notamment dans \textit{Jessie} la version 8 de Debian sur laquelle nous développons et effectuons la plupart de nos tests.
        
        De manière plus générale, depuis les versions 2.6.26 du kernel linux une options activé par défaut, \texttt{CONFIG\_STRICT\_DEVMEM} qui limite l'accès à \texttt{/dev/mem} au premier megabyte. Cela permet d'accéder aux périphériques PCI et certaines régions du BIOS ce qui est suffisant pour les applications qui ont besoins d'utiliser \texttt{/dev/mem} et empêche les applications d'injection du code malicieux. 

        %\texttt{/dev/mem} est un fichier qui fournit un accès à une image de la mémoire physique de la machine. L'intérêt principale est de pouvoir par exemple patché le système rapidement sans avoir à écrire un driver kernel. Comme on peut très vite l'imaginer, \texttt{/dev/mem} a été un point d'entré pour injecter du code malicieux.   L'attaquant va pour cela ciblé la table des appels systèmes en utilisant l'IDT (Interupt Descriptor Table). Il va ensuite changé les entrées de la table système pour qu'elle sur les fonctions du rootkits. Une autre technique consiste à copier la tables des appels système, la modifier et faire pointé le gestionnaire des appels système vers cette nouvelle table et ainsi laisser la table original inchangé.  
        %
        %L'avantage de cette méthode est qu'elle est très discrète par rapport à une injection LKM, en effet le rootkit ne se situe pas directement sur le disque de la machine mais il est présent dans mémoire volatile, ce qui fait qu'une analyse forensic doit pousser son investigation jusque dans la mémoire RAM pour trouver le rootkit. 
        %

    \subsection{Injection via un Loadable Kernel Module (LKM)}

        Les \textit{Loadable Kernel Modules} sont un moyen pratique de modifier le kernel pendant qu'il s'exécute. Ils permettent ainsi de rajouter ou de supprimer des fonctionnalités (comme des drivers) au noyau sans pour autant redémarrer le système ou le recompiler. \\
        
        Ces modules s'exécutent en espace noyau et en possède donc les droits d'exécution. Si un attaquant est capable d'injecter un tel module, alors il pourra avoir la main sur le kernel et, a fortiori, sur l'ensemble de la machine. De la même manière qu'avec l'injection via \texttt{/dev/mem} il est possible de s'attaquer aux appels systèmes et au VFS (section ~\ref{sec:vfs}) pour falsifier les informations que l'administrateur légitime de la machine tenterait d'obtenir et ainsi rendre notre rootkit invisible. \\
        
        Un module kernel a accès aux mêmes fonctionnalités que le kernel, ce qui fait que sa compilation requiert la source du noyau dans lequel on veut l'injecter. Cela peut devenir problématique car les sources ne sont pas nécessairement disponibles sur la machine cible, il faut alors les télécharger ce qui peut attirer l'attention de l'utilisateur légitime, ou bien compiler le LKM sur une autre machine. \\
        
        Une fois que le module a été inséré dans le système, il est, à ce stade, très facile de le détecter. En effet, il est possible de lister les LKM actuellement chargés dans le noyau à l'aide de commandes telles que \texttt{lsmod}, \texttt{modinfo} ou encore \texttt{ls /sys/module/}. Il faut prendre en compte toutes ces méthodes et faire en sorte que l'utilisateur légitime ne puisse pas  détecter notre rootkit uniquement en affichant une simple liste des modules chargés. \\

        % Paragraphe à vérifier et à préciser
        Nous nous sommes renseignés sur deux méthodes permettant de supprimer notre rootkit de ces listes.

        La première se base sur le fait que les informations relatives aux modules sont stockées dans des listes chaînées. Il suffit alors de retirer le rootkit de cette liste et les commandes telles que \texttt{lsmod} ne retourneront plus le nom de notre rootkit. Il faut également le supprimer du dossier \texttt{/sys/module/}. \textbf{YET Pour se faire, l'instruction \texttt{kobject\_del(\&THIS\_MODULE->mobj.kobj)} de retirer l'entrée de notre module au niveau du \texttt{VFS} le retirant ainsi du dossier \texttt{/sys/module/}.}

        La seconde méthode consiste à charger le module avant de le retirer, sachant que la fonction de suppression des modules a été modifiée par le rootkit. La nouvelle fonction de suppression des modules va se comporter comme la fonction originale, sauf que le code du module ne sera pas supprimé. Cela permet de retirer toutes les informations superflues qui pourrait donner des indices à l'utilisateur légitime quant à la présence d'un rootkit, tout en gardant le code de ce dernier. \\
        
        Il existe plusieurs contre-mesures empêchant l'injection de LKM malicieux. La solution la plus radicale consiste à compiler un noyau monolithique en y ajoutant, dès le départ, les modules voulus de manière statique tout en désactivant leur insertion dans le système par la suite.

        Une séconde méthode de prévention consiste à n'autoriser le chargement qu'au démarrage de la machine, ce qui est rendu possible grâce à des solutions pourvues par \textit{grsecurity}. Dans ce cas, les modules choisis sont chargés durant la période de boot et, par la suite, un attaquant ne pourra pas insérer un module tant que le système sera en cours d'exécution.

        % A compléter
        % Si on rajoute un module et qu'on reboot, est-ce que le module sera chargé ?
        % Est-ce que grsecurity remonte des alertes / crée des logs si ces fichiers sont modifiés ? 
        % A tester
        Sinon, comme nous l'avons expliqué précedemment, si l'on ne souhaite pas empêcher l'insertion de LKM, alors il est possible de rajouter des étapes d'authentification et de vérification qui précèderont le chargement du module. En effet, on peut demander un mot de passe à l'utilisateur, rajouter une vérification des modules par signature cryptographique ou encore effectuer automatiquement une analyse statique, voire dynamique, du module avant son insertion.
    
\section{Détournement de l'exécution du noyau}  

Nous avons utilisé deux méthodes différentes afin de détourner le fonctionnement du système. La première se base sur la modification des appels systèmes et la seconde sur le détournement des fonctions du \texttt{Virtual File System}.

    \subsection{Détournement des appels systèmes}
    
        Les appels systèmes sont une interface entre le monde utilisateur et le noyau. De nombreux programmes sont dépendants de ces derniers pour mener leurs tâches à bien. Par exemple, si l'on souhaite cacher un dossier \texttt{rkduck}, il est possible de modifier l'appel système \texttt{getdents}. Ainsi, tous les programmes utilisant \texttt{getdents}, tels que \texttt{find} ou \texttt{ls}, ne seront pas en mesure d'afficher le dossier \texttt{rkduck}.

        La solution la plus directe et la plus simple pour détourner les appels système est de modifier la table des appels système.

    \subsection{Détournement du \texttt{Virtual File System}}
    \label{sec:vfs}
    
        Le \texttt{Virtual File System} (VFS) est une couche de communication se situant entre le kernel et le système de fichier utilisé (ext3, ext4, etc.). C'est le VFS qui se chargera de traduire les instructions envoyées par le kernel pour qu'elle soit compréhensible par le système de fichier.
        L'intérêt de s'attaquer au VFS est de pouvoir cacher des fichiers aux yeux de l'utilisateur légitime. Ainsi, on va pouvoir dissimuler des fichiers, des dossiers, mais aussi des processus grâce à des hooks (i.e modification des pointeurs de fonctions) sur des fonctions du VFS. \\

        Nous allons, dans la suite de cette partie, illustrer nos propos en construisons le système servant à dissimuler un fichier nommé \texttt{rkduck}. Le même principe pourra se généraliser à une liste de fichiers à cacher, mais aussi s'appliquer à la dissimulation de processus.

        Premièrement, nous allons récupérer un pointeur sur la fonction \texttt{iterate} \textbf{(YET pourquoi iterate, qu'est ce que c'est ?)} disponible dans la structure \texttt{file\_operations} afin de la détourner. Étant donné que nous souhaitons ici cacher des fichiers, il faudra que ce pointeur soit relatif à la racine \texttt{/}, pour les processus on pourra se cantoner à \texttt{/proc}. \\

\begin{listing}[H]
\begin{minted}[bgcolor=bg, linenos]{c}
struct file_operations {
  /* [...] */
  int (*iterate) (struct file *, struct dir_context *);
  /* [...] */
};
\end{minted}
\caption{Fonction iterate}
\label{listing:3}
\end{listing}

        Pour récupérer un pointeur sur cette fonction, il faut d'abord récupérer un pointeur vers la structure \texttt{file\_operations} relative à la racine \texttt{/}, ce qui est rendu possible grâce à la fonction \texttt{filp\_open}.\\

\begin{listing}[H]
\begin{minted}[bgcolor=bg, linenos]{c}
void *vfs_get_iterate(const char *path) {
    void *ret;
    struct file *file;

    if ((file = filp_open(path, O_RDONLY, 0)) == NULL)
        return NULL;

    ret = file->f_op->iterate;
    filp_close(file,0);

    return ret;
}
\end{minted}
\caption{Fonction vfs\_get\_iterate dans rkduck}
\label{listing:3}
\end{listing}

        Le détournement de la fonction \texttt{iterate} va s'effectuer de la manière suivante. Dans un premier temps on va garder une copie du pointeur sur cette dernière que l'on appelera \texttt{original\_iterate}. Grâce à ce pointeur on va pouvoir avoir un accès direct à son code, ce qui va nous permettre de le modifier. En effet, on va changer les premières instructions de cette fonction pour qu'elle fasse un saut vers une fonction que l'on contrôle appelée \texttt{hijacked\_iterate}. Il faut également sauvegarder le code de la fonction originale, car cette dernière sera réutilisée plus tard. \\

\begin{figure}[H] 
\begin{center}
\includegraphics[scale=0.5]{./img/vfs_iterate_original_to_hijacked.png}

\caption[dsfsdf]{vfs iterate: original to hijacked}
\end{center}
\end{figure}

\textbf{YET écriture image illisible}

        A présent, la fonction qui va nous intéresser et qui est appelée par \texttt{iterate} est la fonction \texttt{filldir}. Lorsque l'on utilise l'appel système \texttt{getdents} pour lister le contenu d'un dossier, c'est la fonction \texttt{filldir} qui va se charger de remplir les structures contenant les informations sur les éléments contenus dans ce dossier. Ainsi, l'intérêt va être de remplacer cette fonction par une fonction malveillante \texttt{filldir\_hijacked} afin de contrôler quels fichiers nous souhaitons cacher.

        Dans la fonction \texttt{iterate}, c'est un pointeur vers la fonction \texttt{filldir} stocké dans la structure \texttt{struct dir\_context *ctx} qui permet de l'appeler. Ainsi, la fonction \texttt{hijacked\_iterate} aura pour unique but de modifier le pointeur vers la fonction \texttt{filldir} pour qu'il pointe vers notre fonction \texttt{filldir\_hijacked} avant de faire appel à la version originale de \texttt{iterate}.\\

\begin{listing}[H]
\begin{minted}[bgcolor=bg, linenos]{c}
int vfs_hijacked_iterate(struct file *file, struct dir_context *ctx) {
    int ret;

    *((filldir_t *)&ctx->actor) = &vfs_hijacked_filldir;

    vfs_hijack_stop(vfs_original_iterate);
    ret = vfs_original_iterate(file, ctx);
    vfs_hijack_start(vfs_original_iterate);

    return ret;
}
\end{minted}
\caption{Version simplifiée de vfs\_hijacked\_iterate dans rkduck}
\label{listing:3}
\end{listing}

        Comme nous l'avons spécifié précédemment, le code original de la fonction \texttt{iterate} a été sauvegardé. Une fois que l'on a modifié la structure \texttt{struct dir\_context *ctx} pour qu'elle contienne un pointeur vers notre fonction \texttt{hijacked\_filldir}, on rétabli le code original de la fonction \texttt{iterate} grâce à la fonction \texttt{vfs\_hijack\_stop}. Ensuite on appelle \texttt{iterate} qui va maintenant faire appel à notre fonction \texttt{hijacked\_filldir} au lieu de l'original. Ainsi, en recodant \texttt{filldir} pour qu'elle renvoit \texttt{0} lorsqu'un fichier qu'on veut cacher a été passé en paramètre (\texttt{rkduck} dans l'exemple ci-dessous), on peut effectivement dissimuler à l'utilisateur légitime des fichiers malveillants. Il ne reste plus qu'à détourner à nouveau la fonction \texttt{iterate} pour qu'on puisse continuer la dissimulation de fichiers grâce à la fonction \texttt{vfs\_hijack\_start}.\\

\begin{listing}[H]
\begin{minted}[bgcolor=bg, linenos]{c}
static int 
vfs_hijacked_filldir(struct dir_context *ctx, const char *name, 
                     int namelen, loff_t offset, u64 ino, 
                     unsigned int d_type) 
{
    char *get_protect = "rkduck";
    
    if (strstr(name, get_protect)) {
        return 0;
    }

    return vfs_original_filldir(ctx, name, namelen, offset, ino, d_type);
}
\end{minted}
\caption{Version simplifiée de vfs\_hijacked\_filldir dans rkduck}
\label{listing:3}
\end{listing}

Nous avons vu comment utiliser le VFS pour cacher des fichiers, dossiers mais il est aussi utilisé pour cacher les processus ou les ports utilisés par le réseau comme nous le verrons section~\ref{sec:ip} pour dissimuler les backdoors.

\section{Persistance du rootkit}
    
    La persistance du rootkit correspond en quelque sorte à sa durée de vie une fois injecté dans le kernel. Elle est très importante, le but du rootkit étant de récupérer des informations sensibles etc... Sa persistance au sein du système est donc primordiale. \\
    
    Lors d'un redémarrage les modules ajoutés manuellement ne sont pas rechargés, il faut l'indiquer au système. Nous avons donc écrit un script bash qui va écrire le nom de notre module dans un fichier spécifique \texttt{/etc/modules/} (le nom et chemin du fichier n'est pas le même suivant l'OS) et placer notre rootkit compilé dans \texttt{/lib/modules/../kernel/drivers/directory/}. Pour perdre un peu plus l'utilisateur de la machine cible qui pourrait chercher manuellement dans la liste des dossiers drivers un nom suspect et le mettre sur la piste d'une activité malicieuse, le script s'occupe de placer le rooktit compilé au sein d'un dossier légitime exemple : \texttt{/kernel/drivers/tty/rkduck.ko}. Le nom du dossier légitime peut être changé par l'attaquant avant l'injection du module, il pourra pendre soin de renommer aussi le rootkit compilé en un nom qui parait légitime de type \texttt{audio.ko, graphicards.ko} etc.
    
    Lorsque le rootkit est chargé pour la première fois le script s'exécute et à chaque démarrage de la machine notre rootkit sera maintenant chargé au sein du kernel, la persistance est donc acquise et nous pouvons maintenant présenter les différentes fonctionnalités de notre rootkit.

    % A partir du moment où un attaquant a obtenu l'accès à un système, il va souvent chercher à le faire perdurer dans le temps. Afin de faire péréniser cet accès, un rootkit doit être persistant. Il devra donc être capable   
    
\section{Fonctionnalités du rootkit}
    
    \subsection{Dissimulation de fichiers et de processus}
    
        \subsubsection{Fichiers}
            lorem
        \subsubsection{Processus}
            lorem
            
    \subsection{Backdoor}
    
        \subsubsection{Bind shell}
            
            Un bind-shell correspond dans notre cas à un serveur socket qui attend une connexion de la part de l'attaquant pour pouvoir exécuter des commandes shell et renvoyer le résultat. Dans cette optique nous avons mis en place un mini-serveur socket au sein du module kernel qui va simplement attendre les connexions entrantes sur un port spécifique fixé lors de l'injection du rootkit. Une fois la connexion établie, le serveur va attendre les commandes envoyées par l'attaquant, exécuter ces commandes, récupérer le résultat et renvoyer le tout au destinataire. 
            
\begin{figure}[H] 
\begin{center}
\includegraphics{./img/bind-shell.png}

\caption[dsfsdf]{bind shell}
\end{center}
\end{figure}
            
            L'exécution des commandes se fait via l'API\texttt{ call\_usermodhelper(...)}. Comme il n'est pas possible de récupérer le résultat des commandes directement, nous avons donc redirigé la sortie standard vers un fichier temporaire \texttt{/tmp/.cmd}, le résultat est lu puis renvoyé. Lorsque la connexion est interrompue avec l'attaquant le fichier qui contient le résultat de la dernière commande est supprimé.
            
        \subsubsection{Reverse shell}
            
            Le reverse shell consiste à l'opération inverse du bind-shell, ce n'est pas le rootkit qui va attendre une connexion mais l'attaquant qui va se mettre en mode "écoute". Le rootkit quand à lui va initier la connexion vers l'attaquant. (L'adresse ip doit donc être indiquer avant que le rootkit soit injecté). Lorsqu'il reçoit les commandes shell envoyées par l'attaquant le rootkit va se comporter exactement comme le bind shell, c'est à dire copier le résultat dans un fichier temporaire, lire le fichier et renvoyer le résultat.
            
\begin{figure}[H] 
\begin{center}
\includegraphics{./img/reverse-shell.png}

\caption[dsfsdf]{reverse shell}
\end{center}
\end{figure}
            
        \subsubsection{Activation des backdoors}
            
Tout d'abord, l'attaquant choisit d'activer l'une des deux backdoor suivant la situation. Il peut activer et désactiver les backdoors via \textbf{crumb} comme nous l'expliquerons dans la partie (voir section~\ref{sec:crumb}). 
Ensuite il serait inconscient de laisser un bind-shell en écoute toute la journée si on veut rester le plus discret possible. Pour le reverse-shell il faut aussi lui donner un signal pour qu'il puisse se connecter à l'attaquant, nous avons pour cela décidé que la backdoor pourrait s'activer en envoyant un paquet ICMP avec un payload spécifique. Ce payload serait seulement connu de l'attaquant et seul lui peut donc se connecter à sa backdoor.

Nous avons donc implémenté un mini firewall à l'intérieur du rootktit qui va intercepter les paquets et regarder le type et le payload contenu, si il voit par exemple passer un paquet ICMP avec un payload spécifique et une taille de 10 alors il activera la backdoor :
\begin{itemize}
 \item pour le reverse shell le rootkit va essayer de se connecter à l'ip de l'attaquant
 \item pour le bin-shell le rootkit va commencer à écouter et attendre une connexion venant de l'attaquant
\end{itemize}

    Enfin il est possible que les paquets soient filtrés par un firewall externe, par exemple les paquets ICMP comportant un payload pourraient êtres rejetés et l'attaquant n'aurait aucun moyen d'accéder aux backdoors. Nous avons donc mis en place un timer qui va appeler activer la backdoor toutes les 12h. Le temps est bien sur configurable par l'utilisateur à l'injection du rootkit.
        
\begin{figure}[H] 
\begin{center}
\includegraphics{./img/timer-shell.png}

\caption[dsfsdf]{timer shell}
\end{center}
\end{figure}
                    
            
        \subsubsection{SSH backdoor}
        
            Afin de permettre à l'attaquant d'avoir encore plus la main sur la machine corrompu et dans le cas ou le défenseur désactiverait tout les ports non conventionnels, nous avons mis en place une backdoor ssh que l'attaquant est libre d'activer ou non. Elle va tout simplement mettre sa clé publique  dans le fichier \texttt{~/.ssh/authorized\_keys} de root, il peut ainsi tout simplement se connecter en ssh avec l'utilisateur root. Évidement cela suppose que la machine cible est accessible depuis l'extérieur et que root puisse se connecter en ssh (option qui peut être désactivé dans les fichiers de configuration ssh). \\
            
            Nous considérons cette "backdoor" comme options de secours dans le cas ou les autres ne fonctionnerais plus. Elle n'est pas très robuste car il suffit au défenseur de supprimer la clé public  dans le fichiers \texttt{authorized\_keys} mais encore faut il qu'il regarde le fichier et détermine laquelle des clés est la mauvaise. 
            Si nous avons rajouté cette option ssh c'est parce qu'elle est utile si on sait que le défenseur a détecté nos traces (fermeture des ports, filtrage réseaux, commandes  suspects netstat etc), il y a peu de chance qu'il ferme aussi le port ssh. L'attaquant peux alors se connecter directement en ssh et supprimer le rootkit avant que la victime n'est le temps de le récupérer pour une analyse forensic. Ou si la discrétion n'est pas la priorité, l'attaquant peut décider changer les ports, le rootkit de place, supprimer le filtrage  etc. Le but étant comme nous l'avons évoqué plus haut de "perdre" un maximum le défenseur ou de rester le plus discret possible... 
            
            
        \subsubsection{Cacher les connexions réseaux}
        \label{sec:ip}
            lorem
            
    \subsection{Contrôle du rootkit depuis userland}
    \label{sec:crumb}
        lorem
    \subsection{Keylogger}
        lorem
        
\section{Détection du rooktit}
    
    -> honeypot page 12
    
            

\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}
    ct cool

\section*{Annexes}
\addcontentsline{toc}{section}{Annexes}
    Lorem

\addcontentsline{toc}{section}{References}
\bibliographystyle{plain}
\bibliography{bibli}

\end{document}